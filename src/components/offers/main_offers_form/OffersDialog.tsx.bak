import React, { createContext, useCallback, useEffect, useRef, useState, useMemo, useId } from 'react';
import { useForm, UseFormGetValues, UseFormRegister, UseFormReset, UseFormSetError, UseFormSetValue, UseFormWatch, FormState, UseFormHandleSubmit, FieldValues, Control } from 'react-hook-form';
import { supabase } from '@/lib/supabaseClient';
import { useAuth } from '@/lib/AuthContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { toast } from '@/components/ui/use-toast';
import { GlobalDropdown } from '@/components/ui/GlobalDropdown';
import { Check, X, Plus, Save, Calendar } from 'lucide-react';
import { ContactDialog } from '@/components/contacts/ContactDialog';
import {
  AlertDialog,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { useFormRegistration } from '@/lib/FormContext';
import { createTask } from '@/components/tasks/createTask';
import { OffersTableRef } from './OffersTable';
import { validate as uuidValidate } from 'uuid';
import { validateRequired, validateAlphanumeric } from '@/utils/validationUtils';
import ErrorBoundary from '@/components/ErrorBoundary';
import ResourceLockWrapper from '@/components/ui/ResourceLockWrapper';

// Import our new components
import DetailsTab from "./offer-dialog/DetailsTab";
import BasicTab from "./offer-dialog/BasicTab";
import { AppTabs, AppTabsList, AppTabsTrigger, AppTabsContent } from "@/components/ui/app-tabs";

// Import styling
import './offer-dialog/OffersDialog.css';

// Define TypeScript interface for window extension
declare global {
  interface Window {
    offerDetailsSaveFunctions: {
      [key: string]: ((realOfferId: string) => Promise<boolean>) | null;
    };
    _lastSaveDetailsFn: ((realOfferId: string) => Promise<boolean>) | null;
    _updateSaveDetailsFnBackup: (fn: ((realOfferId: string) => Promise<boolean>) | null) => boolean;
    _getSaveDetailsFnBackup: () => ((realOfferId: string) => Promise<boolean>) | null;
    _supabaseTabId?: string;
  }
}

// Create a singleton backup for the save function that persists across rerenders
if (typeof window !== 'undefined') {
  // Initialize backup mechanism
  if (!window._lastSaveDetailsFn) {
    window._lastSaveDetailsFn = null;
  }
  
  // Add a small utility function to update the backup
  if (!window._updateSaveDetailsFnBackup) {
    window._updateSaveDetailsFnBackup = (fn) => {
      if (fn && typeof fn === 'function') {
        window._lastSaveDetailsFn = fn;
        return true;
      }
      return false;
    };
  }
  
  // Add a way to retrieve the backup
  if (!window._getSaveDetailsFnBackup) {
    window._getSaveDetailsFnBackup = () => {
      return window._lastSaveDetailsFn;
    };
  }
}

// Export the props interface so it can be imported by other files
export interface OffersDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  customerId: string;
  offerId?: string;
  onSave: (offer?: any) => void;
  defaultSource?: string;
  tableRef?: React.RefObject<OffersTableRef>;
}

// Define the form values type
interface OfferFormValues {
  customer_id: string;
  offer_date?: string;
  created_at?: string;
  source?: string;
  amount?: string;
  requirements?: string;
  customer_comments?: string;
  our_comments?: string;
  offer_result?: string;
  result?: string;
  assigned_to?: string;
  hma?: boolean;
  certificate?: string;
  address?: string;
  postal_code?: string;
  town?: string;
  status?: string;
}

// Create a context to share state between components
export interface OfferDialogContextType {
  offerId: string | null;
  customerId: string;
  isEditing: boolean;
  register: UseFormRegister<OfferFormValues>;
  watch: UseFormWatch<OfferFormValues>;
  setValue: UseFormSetValue<OfferFormValues>;
  control: Control<OfferFormValues>;
  formState: FormState<OfferFormValues>;
  handleSubmit: UseFormHandleSubmit<OfferFormValues>;
  reset: UseFormReset<OfferFormValues>;
  sourceOptions: any[];
  getSourceLabel: (val: any) => string;
  getSourceValue: (val: any) => any;
  statusOptions: any[];
  getStatusLabel: (val: any) => string;
  getStatusValue: (val: any) => any;
  resultOptions: any[];
  getResultLabel: (val: any) => string;
  getResultValue: (val: any) => any;
  userOptions: string[];
  getUserNameById: (id: string) => string;
  getUserIdByName: (name: string) => string;
  registerSaveDetailsToDatabase?: (saveFn: ((realOfferId: string) => Promise<boolean>) | null) => void;
  registerTabReset?: (tabId: string, resetFn: () => void) => void;
  unregisterTabReset?: (tabId: string) => void;
  registerDeletedDetails?: (detailIds: string | string[] | number | number[]) => void;
}

export const OfferDialogContext = createContext<OfferDialogContextType | null>(null);

// TEMPORARY FIX: Define a hardcoded admin ID as fallback
const ADMIN_USER_ID = '3fbf35f7-5730-47d5-b9d2-f742b24c9d26';

// Wrap the component with React.memo to prevent unnecessary re-renders
const OffersDialog = React.memo(function OffersDialog(props: OffersDialogProps) {
  // Generate a unique instance ID for this component instance
  const instanceId = React.useId();
  
  // Check if props is null or undefined
  if (!props || !props.customerId) {
    console.error("OffersDialog received invalid props", props);
    return null;
  }
  
  const {
    open,
    onOpenChange,
    customerId,
    offerId: initialOfferId,
    onSave,
    defaultSource = "Email",
    tableRef,
  } = props;
  
  // Use useRef to track if this is the first render
  const isFirstRender = React.useRef(true);
  
  // Log initialization only on first render
  React.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    }
  }, []);
  
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);
  const [users, setUsers] = useState<any[]>([]);
  const [isEditing, setIsEditing] = useState(false);
  const [userOptions, setUserOptions] = useState<string[]>([]);
  const [userMap, setUserMap] = useState<Record<string, string>>({});
  const [customerName, setCustomerName] = useState("");
  const [customerPhone, setCustomerPhone] = useState("");
  const [offerId, setOfferId] = useState<string | undefined>(initialOfferId);
  const [contacts, setContacts] = useState<any[]>([]);
  const [contactOptions, setContactOptions] = useState<string[]>([]);
  const [contactMap, setContactMap] = useState<Record<string, string>>({});
  const [contactDisplayMap, setContactDisplayMap] = useState<Record<string, string>>({});
  const [selectedContactId, setSelectedContactId] = useState<string | null>(null);
  const [showContactDialog, setShowContactDialog] = useState(false);
  const [selectedContact, setSelectedContact] = useState(null);
  const [error, setError] = useState("");
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [formDisabled, setFormDisabled] = useState(false);
  
  // Track deleted detail IDs for batch deletion
  const [deletedDetailIds, setDeletedDetailIds] = useState<(string | number)[]>([]);
  
  // Add a ref to store deleted detail IDs - using the correct type for both string and number IDs
  const deletedDetailsRef = React.useRef<(string | number)[]>([]);
  
  // Function to register details for deletion
  const registerDeletedDetails = useCallback((detailId: string | string[] | number | number[]) => {
    // Update the ref for immediate access
    if (Array.isArray(detailId)) {
      // Convert all IDs to strings for consistency
      const stringIds = detailId.map(id => id.toString());
      deletedDetailsRef.current = [...deletedDetailsRef.current, ...stringIds];
    } else {
      // Convert ID to string for consistency
      deletedDetailsRef.current = [...deletedDetailsRef.current, detailId.toString()];
    }
    
    // Also update the state for component re-renders and persistence
    if (Array.isArray(detailId)) {
      // Convert all IDs to strings for consistency
      const stringIds = detailId.map(id => id.toString());
      setDeletedDetailIds(prev => [...prev, ...stringIds]);
    } else {
      // Convert ID to string for consistency
      setDeletedDetailIds(prev => [...prev, detailId.toString()]);
    }
  }, []);
  
  // Register this form when it's open
  useFormRegistration(
    isEditing 
      ? `Επεξεργασία Προσφοράς: ${customerName || customerId}`
      : `Νέα Προσφορά: ${customerName || customerId}`, 
    open
  );
  
  // Date formatting utility functions
  const dateFormatUtils = useMemo(() => {
    return {
      // Format current date and time in ISO format for datetime-local input
      formatCurrentDateTimeForInput: (date?: string) => {
        try {
          const now = date ? new Date(date) : new Date();
          now.setMilliseconds(0); // Reset milliseconds for consistency
          
          // First return a proper ISO string for the database
          return now.toISOString();
        } catch (error) {
          console.error("Error formatting date:", error);
          return new Date().toISOString();
        }
      },
      
      // Format date for display
      formatDateForDisplay: (dateString: string) => {
        if (!dateString) return "";
        try {
          const date = new Date(dateString);
          return date.toLocaleDateString("el-GR", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
          }) + " " + date.toLocaleTimeString("el-GR", {
            hour: "2-digit",
            minute: "2-digit"
          });
        } catch (error) {
          return "";
        }
      }
    };
  }, []);
  
  // Extract validation functions for convenience
  const { isFormValid, normalizeAmount } = dateFormatUtils;
  
  // Format current date and time in ISO format for datetime-local input
  const formatCurrentDateTimeForInput = (date?: string) => {
    try {
      const now = date ? new Date(date) : new Date();
      now.setMilliseconds(0); // Reset milliseconds for consistency
      
      // First return a proper ISO string for the database
      return now.toISOString();
    } catch (error) {
      console.error("Error formatting date:", error);
      return new Date().toISOString();
    }
  };
  
  const [currentDate, setCurrentDate] = useState(formatCurrentDateTimeForInput());
  
  // Status and result options with display text
  const sourceOptions = [
    { value: "Email", label: "Email" },
    { value: "Phone", label: "Τηλέφωνο" },
    { value: "Site", label: "Site" },
    { value: "Physical", label: "Φυσική Παρουσία" }
  ];
  
  const statusOptions = [
    { value: "wait_for_our_answer", label: "Αναμονή για απάντησή μας" },
    { value: "wait_for_customer_answer", label: "Αναμονή για απάντηση πελάτη" },
    { value: "ready", label: "Ολοκληρώθηκε" }
  ];
  
  const resultOptions = [
    { value: "none", label: "Κανένα" },
    { value: "success", label: "Επιτυχία" },
    { value: "failed", label: "Αποτυχία" },
    { value: "cancel", label: "Ακύρωση" },
    { value: "waiting", label: "Αναμονή" }
  ];

  // Create reusable option mapping functions
  const createOptionMappers = (options: Array<{value: string, label: string}>) => {
    return {
      getLabel: (value: string) => options.find(option => option.value === value)?.label || value,
      getValue: (label: string) => options.find(option => option.label === label)?.value || label
    };
  };
  
  // Create mappers for each option type
  const sourceMappers = useMemo(() => createOptionMappers(sourceOptions), []);
  const statusMappers = useMemo(() => createOptionMappers(statusOptions), []);
  const resultMappers = useMemo(() => createOptionMappers(resultOptions), []);
  
  // Helper functions for source, status, and result - keep these for backward compatibility
  const getSourceLabel = useCallback((value: string) => {
    switch (value) {
      case "Email":
        return "Email";
      case "Phone":
      case "Telephone":
        return "Τηλέφωνο";
      case "Website":
      case "Site":
        return "Ιστοσελίδα";
      case "In Person":
      case "Physical":
        return "Φυσική παρουσία";
      default:
        return value;
    }
  }, []);
  
  const getSourceValue = useCallback((label: string) => {
    switch (label) {
      case "Email":
        return "Email";
      case "Τηλέφωνο":
        return "Phone";
      case "Ιστοσελίδα":
      case "Site":
        return "Site";
      case "Φυσική παρουσία":
      case "Φυσική Παρουσία":
        return "Physical";
      default:
        return label;
    }
  }, []);

  const getStatusLabel = (value: string) => {
    return statusOptions.find(option => option.value === value)?.label || value;
  };
  
  const getStatusValue = (label: string) => {
    return statusOptions.find(option => option.label === label)?.value || label;
  };
  
  const getResultLabel = (value: string) => {
    return resultOptions.find(option => option.value === value)?.label || value;
  };
  
  const getResultValue = (label: string) => {
    return resultOptions.find(option => option.label === label)?.value || label;
  };

  const defaultValues = useMemo(() => {
    // Create a single date string for both fields
    const dateString = formatCurrentDateTimeForInput();
    
    return {
      customer_id: String(customerId),
      offer_date: dateString, // For UI display only
      created_at: dateString, // This is what will be saved to DB
      source: defaultSource,
      amount: "",
      requirements: "",
      customer_comments: "",
      our_comments: "",
      offer_result: "wait_for_our_answer",
      result: null,
      assigned_to: user?.id || "",
      hma: false,
      certificate: "",
      address: "",
      postal_code: "",
      town: ""
    };
  }, [customerId, defaultSource, user?.id]);

  // Initialize form with react-hook-form
  const {
    register,
    watch,
    setValue,
    reset,
    control,
    handleSubmit,
    formState,
    getValues,
  } = useForm<OfferFormValues>({
    defaultValues: {
      customer_id: String(customerId),
      offer_date: formatCurrentDateTimeForInput(), // For UI display only
      created_at: formatCurrentDateTimeForInput(), // This is what will be saved to DB
      source: defaultSource,
      amount: "",
      requirements: "",
      customer_comments: "",
      our_comments: "",
      offer_result: "wait_for_our_answer",
      result: "none",
      assigned_to: user?.id || "",
      hma: false,
      certificate: "",
      address: "",
      postal_code: "",
      town: "",
      status: "active"
    }
  });
  
  // Effect to set default values when the component mounts or when defaultSource changes
  useEffect(() => {
    if (defaultSource) {
      setValue('source', defaultSource);
    }
  }, [defaultSource, setValue]);
  
  // useEffect for form reset
  useEffect(() => {
    if (open) {
      reset({
        customer_id: customerId || '',
        offer_date: formatCurrentDateTimeForInput(),
        created_at: formatCurrentDateTimeForInput(),
        source: defaultSource || '',
        amount: '', // Ensure amount starts as empty string
        requirements: '',
        customer_comments: '',
        our_comments: '',
        offer_result: 'wait_for_our_answer',
        result: 'none',
        assigned_to: user?.id || '',
        hma: false,
        certificate: '',
        address: '',
        postal_code: '',
        town: '',
        status: 'active'
      });
      
      // Clear any errors
      setError("");
    }
  }, [open, reset, customerId, defaultSource, user?.id]);

  // Fetch users for assignment dropdown
  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const { data, error } = await supabase
          .from("users")
          .select("id, fullname")
          .eq("status", "active");

        if (error) throw error;
        
        // Create a map of user IDs to names
        const userIdToName: Record<string, string> = {};
        const userNameOptions: string[] = [];
        
        data?.forEach(user => {
          userIdToName[user.id] = user.fullname;
          userNameOptions.push(user.fullname);
        });
        
        setUserMap(userIdToName);
        setUserOptions(userNameOptions);
        setUsers(data || []);
      } catch (error) {
        console.error("Error fetching users:", error);
      }
    };

    fetchUsers();
  }, []);

  // Helper function to convert between user ID and name
  const getUserIdByName = (name: string) => {
    // First try to find the user in the users array
    const user = users.find(u => u.fullname === name);
    if (user?.id) {
      return user.id;
    }
    
    // If not found in users array, try to find in the userMap
    const userEntry = Object.entries(userMap).find(([_, userName]) => userName === name);
    if (userEntry) {
      return userEntry[0]; // Return the user ID
    }
    
    // If still not found, log a warning and return the current user's ID as fallback
    console.warn(`User with name "${name}" not found. Using current user as fallback.`);
    return user?.id || "";
  };

  const getUserNameById = (id: string) => {
    return userMap[id] || "";
  };

  // Fetch customer data including address
  useEffect(() => {
    const fetchCustomerData = async () => {
      try {
        // Validate customerId format (should be a UUID)
        if (!uuidValidate(customerId)) {
          return;
        }
        
        // Try a different approach with the query
        const { data, error } = await supabase
          .from("customers")
          .select("*")  // Select all columns first
          .eq("id", customerId)
          .single();

        if (error) throw error;
        
        if (data) {
          // Set customer name and phone
          setCustomerName(data.company_name);
          setCustomerPhone(data.telephone || "");
        }
      } catch (error) {
        console.error("Error fetching customer data:", error);
      }
    };

    if (customerId) {
      fetchCustomerData();
    }
  }, [customerId]);

  // Fetch offer data if editing
  useEffect(() => {
    if (offerId) {
      setIsEditing(true);
      const fetchOffer = async () => {
        try {
          setLoading(true);
          
          const { data, error } = await supabase
            .from("offers")
            .select("*")
            .eq("id", offerId)
            .single();

          if (error) {
            throw error;
          }
          
          if (data) {
            // Get the date from created_at in the database
            const dateString = data.created_at || formatCurrentDateTimeForInput();
            
            // Reset the form first to clear any existing values
            reset({
              // Use created_at for both fields since offer_date doesn't exist in DB
              customer_id: String(customerId),
              offer_date: dateString,
              created_at: dateString,
              source: (data as any).source || defaultSource,
              amount: (data as any).amount || "",
              requirements: (data as any).requirements || "",
              customer_comments: (data as any).customer_comments || "",
              our_comments: (data as any).our_comments || "",
              offer_result: (data as any).offer_result || "wait_for_our_answer",
              result: (data as any).result || null,
              assigned_to: (data as any).assigned_to || user?.id || "",
              hma: (data as any).hma || false,
              certificate: (data as any).certificate || "",
              address: (data as any).address || "",
              postal_code: (data as any).tk || "", // Map tk from database to postal_code in form
              town: (data as any).town || ""
            });
            
            // Set the contact ID from the fetched data
            setSelectedContactId(data.contact_id || null);
          }
        } catch (error) {
          console.error("Error fetching offer:", error);
        } finally {
          setLoading(false);
        }
      };

      fetchOffer();
    } else {
      setIsEditing(false);
      reset(defaultValues);
    }
  }, [offerId, open, defaultSource, reset, setValue, user?.id]);

  // Helper function to fetch contacts - extract this outside useEffect for reuse
  const fetchContacts = useCallback(async () => {
    if (!customerId) return;
    
    try {
      const { data, error } = await supabase
        .from("contacts")
        .select("id, full_name, position, created_at")
        .eq("customer_id", customerId)
        .eq("status", "active")
        .is("deleted_at", null);

      if (error) throw error;
      
      // Create a map of contact IDs to names and display names
      const contactIdToName: Record<string, string> = {};
      const contactIdToDisplayName: Record<string, string> = {};
      const contactNameOptions: string[] = [];
      
      data?.forEach(contact => {
        // Store full name without position for the dropdown header
        contactIdToName[contact.id] = contact.full_name;
        
        // Store display name with position for the dropdown options
        const displayName = contact.position 
          ? `${contact.full_name} (${contact.position})` 
          : contact.full_name;
        
        contactIdToDisplayName[contact.id] = displayName;
        contactNameOptions.push(displayName);
      });
      
      setContactMap(contactIdToName);
      setContactDisplayMap(contactIdToDisplayName);
      setContactOptions(contactNameOptions);
      setContacts(data || []);
      
      // If we have contacts and no contact is selected, select the first one
      if (data && data.length > 0 && !selectedContactId) {
        setSelectedContactId(data[0].id);
      }
    } catch (error) {
      console.error("Error fetching contacts:", error);
    }
  }, [customerId, selectedContactId]);

  // Fetch customer contacts
  useEffect(() => {
    if (open) {
      fetchContacts();
    }
  }, [open, fetchContacts]);

  // Helper functions for contacts
  const getContactIdByName = (name: string) => {
    // Find the contact ID by the display name (which includes position)
    const contactEntry = Object.entries(contactDisplayMap).find(([_, value]) => value === name);
    return contactEntry ? contactEntry[0] : "";
  };

  const getContactNameById = (id: string) => {
    // Return just the full name for the selected value in the dropdown header
    return contactMap[id] || "";
  };
  
  const getContactDisplayNameById = (id: string) => {
    const contact = contacts.find((c) => c.id === id);
    if (!contact) return "";
    // Return only the full name without the position
    return contact.full_name;
  };

  // Tab reset functions
  const [detailsTabReset, setDetailsTabReset] = useState<(() => void) | null>(null);
  
  // Function to register a tab reset function
  const registerTabReset = useCallback((tabId: string, resetFn: () => void) => {
    if (tabId === 'details') {
      setDetailsTabReset(() => resetFn);
    }
  }, []);
  
  // Function to unregister a tab reset function
  const unregisterTabReset = useCallback((tabId: string) => {
    if (tabId === 'details') {
      setDetailsTabReset(null);
    }
  }, []);
  
  // Function to reset all tabs
  const resetAllTabs = useCallback(() => {
    if (detailsTabReset) {
      try {
        detailsTabReset();
      } catch (error) {
        // Silently catch errors
      }
    }
  }, [detailsTabReset]);

  // Function to save offer data and get the ID
  const saveOfferAndGetId = async (formData: any): Promise<string | null> => {
    try {
      // Get offerId from state, don't reassign it (was causing a linter error)
      const currentOfferId = offerId;
      
      // Ensure customerId is treated as a string
      const customerIdString = String(customerId);
      
      // CRITICAL FIX: Use a known working user ID to bypass the foreign key constraint issue
      // This is a temporary workaround until the root cause can be identified
      let safeUserId = ADMIN_USER_ID;
      
      // Normalize the source and amount values
      const normalizeSourceValue = (source: string | null | undefined): string => {
        if (!source) return "Email"; // Default value
        
        // Map to valid enum values
        switch(source) {
          case "Email": return "Email";
          case "Phone": return "Phone";
          case "Site": return "Site";
          case "Physical": return "Physical";
          case "Τηλέφωνο": return "Phone";
          case "Ιστοσελίδα": return "Site";
          case "Φυσική παρουσία": return "Physical";
          case "Φυσική Παρουσία": return "Physical";
          default: 
            console.warn(`⚠️ Unknown source value: "${source}". Defaulting to "Email".`);
            return "Email";
        }
      };
      
      if (currentOfferId && !currentOfferId.startsWith('temp-')) {
        // If we have a real offer ID, update the existing offer
        
        const updateData = {
          customer_id: String(customerIdString),
          offer_result: formData.offer_result || "wait_for_our_answer",
          result: formData.result || null,
          our_comments: formData.our_comments || null,
          customer_comments: formData.customer_comments || null,
          requirements: formData.requirements || null,
          amount: normalizeAmount(formData.amount),
          source: normalizeSourceValue(formData.source),
          address: formData.address || null,
          tk: formData.postal_code || null,
          town: formData.town || null,
          hma: !!formData.hma,
          certificate: formData.certificate || null,
          updated_by: safeUserId,  // Use the hardcoded ID
          updated_at: new Date().toISOString(),
          contact_id: selectedContactId
        };
        
        const { data, error } = await supabase
          .from("offers")
          .update(updateData as any)
          .eq("id", currentOfferId)
          .select()
          .single();
        
        if (error) {
          console.error("Error updating offer:", error);
          throw error;
        }
        
        return data.id;
      } else {
        // Create new offer
        
        const insertData = {
          customer_id: String(customerIdString),
          offer_result: formData.offer_result || "wait_for_our_answer",
          result: formData.result || null,
          our_comments: formData.our_comments || null,
          customer_comments: formData.customer_comments || null,
          requirements: formData.requirements || null,
          amount: normalizeAmount(formData.amount),
          source: normalizeSourceValue(formData.source),
          address: formData.address || null,
          tk: formData.postal_code || null,
          town: formData.town || null,
          hma: !!formData.hma,
          certificate: formData.certificate || null,
          created_by: safeUserId,  // Use the hardcoded ID
          updated_by: safeUserId,  // Use the hardcoded ID
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          contact_id: selectedContactId
        };
        
        const { data: newOffer, error } = await supabase
          .from('offers')
          .insert(insertData as any)
          .select()
          .single();
          
        if (error) {
          console.error("Error creating offer:", error);
          throw error;
        }
        
        // Update component state with the new offer ID (don't use setOfferId here, use the return value)
        return newOffer.id;
      }
    } catch (error) {
      console.error("Error in saveOfferAndGetId:", error);
      return null;
    }
  };

  // Add a ref to store the saveDetailsToDatabase function
  const saveDetailsToDatabaseRef = React.useRef<((realOfferId: string) => Promise<boolean>) | null>(null);
  
  // Store the save function persistently, outside of React's normal state flow
  // to ensure it doesn't get lost during rerenders
  const persistentSaveFnRef = React.useRef<((realOfferId: string) => Promise<boolean>) | null>(null);
  
  // Function to register the saveDetailsToDatabase function
  const registerSaveDetailsToDatabase = useCallback((saveFn: ((realOfferId: string) => Promise<boolean>) | null) => {
    if (saveFn === null) {
      return; // Don't clear the function, just ignore null assignments
    }
    
    // Store in the ref for immediate component use
    saveDetailsToDatabaseRef.current = saveFn;
    
    // Also store in a persistent ref that won't be affected by React's lifecycle
    persistentSaveFnRef.current = saveFn;
    
    // Update the global registry with an instanceId
    if (typeof window !== 'undefined') {
      // Initialize the global registry if it doesn't exist
      if (!window.offerDetailsSaveFunctions) {
        window.offerDetailsSaveFunctions = {};
      }
      
      // Add to global registry with the instance ID
      window.offerDetailsSaveFunctions[instanceId] = saveFn;
      
      // Update the global backup
      if (window._updateSaveDetailsFnBackup) {
        window._updateSaveDetailsFnBackup(saveFn);
      }
    }
  }, []); 

  // Create the context value with useMemo to optimize performance
  const contextValue = useMemo(() => ({
    offerId, 
    customerId, 
    isEditing,
    register,
    watch,
    setValue,
    control,
    formState,
    handleSubmit,
    reset,
    sourceOptions,
    getSourceLabel,
    getSourceValue,
    statusOptions,
    getStatusLabel,
    getStatusValue,
    resultOptions,
    getResultLabel,
    getResultValue,
    userOptions,
    getUserNameById,
    getUserIdByName,
    registerSaveDetailsToDatabase,
    registerTabReset,
    unregisterTabReset,
    registerDeletedDetails
  }), [
    offerId, 
    customerId, 
    isEditing,
    register,
    watch,
    setValue,
    control,
    formState,
    handleSubmit,
    reset,
    sourceOptions,
    getSourceLabel,
    getSourceValue,
    statusOptions,
    getStatusLabel,
    getStatusValue,
    resultOptions,
    getResultLabel,
    getResultValue,
    userOptions,
    getUserNameById,
    getUserIdByName,
    registerSaveDetailsToDatabase,
    registerTabReset,
    unregisterTabReset,
    registerDeletedDetails
  ]);

  // Find where contactOptions are created or where the dropdown is rendered
  // It might look something like this:
  useEffect(() => {
    // Update contact options to only include full name
    const options = contacts.map(contact => contact.full_name);
    setContactOptions(options);
    
    // Update the display map to only use full name
    const displayMap = {};
    contacts.forEach(contact => {
      displayMap[contact.id] = contact.full_name; // Only use full_name
    });
    setContactDisplayMap(displayMap);
  }, [contacts]);

  // Add state for showing success/error in the dialog footer
  const [saveSuccess, setSaveSuccess] = useState(false);
  
  // Form submit handler - actually save the offer
  const onSubmit = handleSubmit(async (data) => {
    if (isSubmitting) return;
    
    try {
      setIsSubmitting(true);
      setSubmitError(null);
      setSaveSuccess(false);
      
      // Explicitly set customer_id in the form data to ensure it's available
      data.customer_id = String(customerId);
      
      // Validate form before proceeding
      if (!isFormValid()) {
        return;
      }
      
      // Save the main offer data and get the offer ID
      const savedOfferId = await saveOfferAndGetId(data);
      
      if (!savedOfferId) {
        setSubmitError('Failed to save offer data');
        setIsSubmitting(false);
        return;
      }
      
      // Now that we have a valid offer ID, save the offer details
      // via the registered save function
      let detailsSaveResult = false;
      
      // Try to get the save function from the ref
      const saveFn = saveDetailsToDatabaseRef.current;
      
      if (saveFn && typeof saveFn === 'function') {
        try {
          detailsSaveResult = await saveFn(savedOfferId);
        } catch (detailsError) {
          // Continue with main flow even if details fail
        }
      }
      
      // Set the success state to trigger UI feedback
      setSaveSuccess(true);
      
      // If this was a new offer, update the UI with the new ID
      if (!offerId) {
        setOfferId(savedOfferId);
      }
      
      // Close dialog for new offers after successful save
      if (!isEditing) {
        onOpenChange(false);
      }
    } catch (error) {
      setSubmitError('An error occurred while saving the offer.');
    } finally {
      setIsSubmitting(false);
    }
  });

  const watchOfferResult = watch("offer_result");
  const watchResult = watch("result");
  const watchHma = watch("hma");
  
  // Add console log when form is fully loaded
  useEffect(() => {
    if (open) {
      // Check if key DOM elements are rendered
      setTimeout(() => {
        // Ensure amount is not accidentally set to a Greek translation of source
        // NOTE: The amount field is ALWAYS a string, never a number
        const currentAmount = watch("amount");
        if (typeof currentAmount === "string" && 
            (currentAmount === "Τηλέφωνο" || 
             currentAmount === "τηλέφωνο" || 
             currentAmount === "tilefono" || 
             currentAmount === "Phone")) {
          setValue("amount", "");
        }
      }, 100);
    }
  }, [open]); // Intentionally omitting watch and setValue to avoid re-runs

  // Helper function for initializing tooltips
  const initializeTooltips = useCallback(() => {
    // Initialize tooltips by ensuring all tooltip refs are set to mounted
    setTimeout(() => {
      document.querySelectorAll('[data-tooltip-mounted]').forEach(el => {
        try {
          if ((el as any).tooltipMountedRef) {
            (el as any).tooltipMountedRef.current = true;
          }
        } catch (e) {
          // Silent error
        }
      });
    }, 100);
  }, []);

  // If you're doing focus operations when the dialog opens
  useEffect(() => {
    if (open) {
      // Let the dialog render first
      requestAnimationFrame(() => {
        // Then focus in the next frame
        requestAnimationFrame(() => {
          const element = document.querySelector('.dialog-content input') as HTMLElement;
          if (element) element.focus();
          
          // Initialize tooltips by ensuring all tooltip refs are set to mounted
          document.querySelectorAll('[data-tooltip-mounted]').forEach(el => {
            try {
              if ((el as any).tooltipMountedRef) {
                (el as any).tooltipMountedRef.current = true;
              }
            } catch (e) {
              // Silent error
            }
          });
        });
      });
    }
  }, [open]);

  // Add state for date picker
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);
  const dateButtonRef = useRef(null);
  const [calendarPosition, setCalendarPosition] = useState({ top: 0, left: 0 });
  // Add state for calendar current month and year
  const [calendarDate, setCalendarDate] = useState(() => new Date());

  // Toggle calendar
  const toggleCalendar = () => {
    if (!isCalendarOpen && dateButtonRef.current) {
      const rect = dateButtonRef.current.getBoundingClientRect();
      setCalendarPosition({
        top: rect.bottom + window.scrollY + 4,
        left: rect.left + window.scrollX + (rect.width / 2) - 160 // 160 is half of 320px calendar width
      });
      setCalendarDate(new Date()); // Reset to current month when opening calendar
    }
    setIsCalendarOpen(!isCalendarOpen);
  };

  // Handle outside clicks for date picker
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (isCalendarOpen && 
          dateButtonRef.current && 
          !(dateButtonRef.current as any).contains(event.target) &&
          !(event.target as Element).closest('.date-picker-dropdown')) {
        setIsCalendarOpen(false);
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isCalendarOpen]);

  // Helper function for cleanup tooltips and dialog-related DOM elements
  const cleanupTooltipsAndPortals = useCallback(() => {
    try {
      // Find any tooltip portals in the DOM and remove them manually
      document.querySelectorAll('[data-radix-tooltip-portal]').forEach(portal => {
        try {
          if (portal.parentNode) {
            portal.parentNode.removeChild(portal);
          }
        } catch (e) {
          // Silent cleanup error
        }
      });
      
      // Make sure tooltips mounted refs are set to true
      document.querySelectorAll('[data-tooltip-mounted]').forEach(el => {
        try {
          if ((el as any).tooltipMountedRef) {
            (el as any).tooltipMountedRef.current = true;
          }
        } catch (e) {
          // Silent cleanup error
        }
      });
    } catch (e) {
      // Ignore any errors in cleanup
    }
  }, []);

  return (
    <OfferDialogContext.Provider value={contextValue}>
      <ErrorBoundary fallback={
        <div className="fixed inset-0 flex items-center justify-center bg-black/50 z-50">
          <div className="bg-[#2f3e46] p-6 rounded-md shadow-lg border border-[#52796f] max-w-md">
            <h2 className="text-xl font-semibold text-[#cad2c5] mb-4">An error occurred</h2>
            <p className="text-[#cad2c5] mb-6">There was a problem loading the Offers Dialog. Please try again.</p>
            <button 
              onClick={() => onOpenChange(false)} 
              className="bg-[#52796f] text-[#cad2c5] px-4 py-2 rounded-md hover:bg-[#354f52]"
            >
              Close
            </button>
          </div>
        </div>
      }>
        <Dialog open={open} onOpenChange={(newOpen) => {
          // Only reset tabs when dialog is closing, not when opening
          if (open && !newOpen) {
            // Clean up tooltips before closing the dialog
            cleanupTooltipsAndPortals();
            
            // Wait a short time before resetting tabs
            setTimeout(() => {
              resetAllTabs();
            }, 0);
          }
          
          onOpenChange(newOpen);
        }}>
          <DialogContent
            className="bg-[#2f3e46] border-[#52796f] text-[#cad2c5] max-w-5xl w-[85vw] max-h-[95vh] min-h-[800px] flex flex-col overflow-hidden p-0 gap-0"
            aria-labelledby="offer-dialog-title"
            aria-describedby="offer-dialog-description"
            onInteractOutside={(e) => {
              e.preventDefault(); // Prevent closing on outside click
            }}
            onEscapeKeyDown={(e) => {
              e.preventDefault(); // Prevent closing on escape key
            }}
            onPointerDownOutside={(e) => {
              e.preventDefault(); // Prevent closing on pointer down outside
            }}
          >
            {/* DialogTitle with proper placement for accessibility */}
            <DialogTitle id="offer-dialog-title" className="sr-only" style={{
              position: 'absolute',
              width: '1px',
              height: '1px',
              padding: '0',
              margin: '-1px',
              overflow: 'hidden',
              clip: 'rect(0, 0, 0, 0)',
              whiteSpace: 'nowrap',
              borderWidth: '0'
            }}>
              {isEditing ? "Επεξεργασία Προσφοράς" : "Νέα Προσφορά"}
            </DialogTitle>
            
            <ResourceLockWrapper 
              resourceType="offers"
              resourceId={offerId || null}
              autoAcquire={!!offerId} // Only auto-acquire lock for existing offers
              hideLockStatus={true} // Always hide the lock status indicator
              onLockStatusChange={(status, owner) => {
                if (status === 'locked_by_other') {
                  console.log(`🔒 [LOCK] Offer is locked by ${owner?.name}, setting form to read-only`);
                  setFormDisabled(true);
                } else if (status === 'locked_by_me') {
                  console.log(`🔒 [LOCK] I have the lock on this offer, enabling form`);
                  setFormDisabled(false);
                } else if (status === 'unlocked') {
                  console.log(`🔒 [LOCK] Offer is unlocked, enabling form`);
                  setFormDisabled(false);
                } else if (status === 'error') {
                  console.log(`🔒 [LOCK] Error with lock, defaulting to read-only`);
                  setFormDisabled(true);
                }
              }}
            >
            <style>
              {`
              /* Add specific styling for the close button to ensure it's above all other elements */
              .max-w-4xl [role="dialog"] > .absolute.right-4.top-4 {
                position: absolute;
                z-index: 9999 !important;
                right: 1rem !important;
                top: -2.5rem !important;
                pointer-events: auto !important;
                transform: translateY(-50%) !important;
                background-color: #2f3e46 !important;
                border: 1px solid #52796f !important;
                border-radius: 50% !important;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3) !important;
              }
              
              /* Ensure footer buttons are always visible and fixed at bottom */
              .dialog-footer {
                position: fixed;
                bottom: 0;
                right: 0;
                left: 0;
                z-index: 60;
                padding: 12px 24px;
                background-color: #2f3e46;
                border-top: 1px solid #52796f;
                display: flex;
                align-items: center;
                justify-content: flex-end;
                box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
              }
              
              /* Ensure any parent container doesn't interfere with the close button */
              .max-w-4xl [role="dialog"] {
                position: relative !important;
              }
              
              /* Center dialog on the screen */
              .max-w-4xl {
                position: fixed !important;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
                margin: 0 !important;
              }
              
              /* Ensure all parent elements allow pointer events to pass through to the close button */
              .dialog-content, 
              .app-tabs-container,
              [role="tablist"],
              [data-radix-tabs-content] {
                pointer-events: auto !important;
              }
              
              /* DialogContent wrapper for consistent display and scrolling */
              .dialog-content {
                display: flex;
                flex-direction: column;
                height: 100%;
                width: 100%;
                position: relative;
                z-index: 1;
              }
              
              /* Make form fill available space */
              .dialog-content form {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                border-bottom: none;
                position: relative;
                z-index: 2;
              }

              /* Additional style to ensure form inputs are interactive */
              .dialog-content form input,
              .dialog-content form textarea,
              .dialog-content form select,
              .dialog-content form button {
                position: relative;
                z-index: 10;
                pointer-events: auto;
              }
              
              /* Tab specific styling */
              .app-tabs-container {
                height: 100%;
                display: flex;
                flex-direction: column;
                position: relative;
                z-index: 3;
              }
              
              /* Ensure tab triggers are properly positioned */
              [role="tablist"] {
                position: sticky !important;
                top: 0;
                z-index: 50;
                background-color: #2f3e46;
              }
              
              /* Make sure tab content fills the available space */
              [data-radix-tabs-content] {
                height: 100%;
                padding-bottom: 80px; /* Ensure space for footer */
                background-color: #2a3b42; /* Darker background color for tab content */
                position: relative; /* Add position relative */
                z-index: 4; /* Lower z-index than tab triggers but higher than other elements */
                margin-bottom: 60px; /* Add margin to ensure content doesn't get cut off by footer */
              }

              /* Section styling */
              [data-radix-tabs-content] > div > div {
                margin-bottom: 1rem;
                border: 1px solid #52796f;
                background-color: #2a3b42; /* Add darker background to sections */
                padding: 1rem;
                border-radius: 0.375rem;
                position: relative; /* Add position relative */
                z-index: 5; /* Make sure sections appear above the tab content background */
              }
              
              /* Delete button styling */
              .delete-btn {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 24px;
                height: 24px;
                border-radius: 4px;
                color: #84a98c;
                background-color: transparent;
                border: none;
                cursor: pointer;
                transition: all 0.2s ease;
              }
              
              .delete-btn:hover {
                background-color: rgba(53, 79, 82, 0.7);
              }
              
              .delete-btn:focus {
                outline: none;
              }
              
              /* Ensure cursor is visible on hover */
              .delete-btn:hover svg {
                color: #cad2c5;
              }
              
              /* Add visual feedback on active state */
              .delete-btn:active {
                transform: scale(0.95);
              }
              
              textarea {
                min-height: 4rem !important;
                resize: none !important;
              }
              
              /* Custom text selection colors with !important to override */
              .max-w-4xl *::selection {
                background-color: #52796f !important;
                color: #cad2c5 !important;
              }
              
              .max-w-4xl *::-moz-selection {
                background-color: #52796f !important;
                color: #cad2c5 !important;
              }

              /* Style for rows being deleted */
              .deleting-row {
                background-color: rgba(255, 0, 0, 0.05) !important;
                transition: all 0.3s ease;
                pointer-events: none;
              }
              
              /* Ensure tooltips are visible */
              [data-radix-tooltip-portal] {
                z-index: 9999 !important;
                pointer-events: none !important;
                visibility: visible !important;
                opacity: 1 !important;
                display: block !important;
              }
              
              [data-state="delayed-open"][data-radix-tooltip-portal],
              [data-state="instant-open"][data-radix-tooltip-portal] {
                display: block !important;
                opacity: 1 !important;
                visibility: visible !important;
              }
              
              /* Fix tooltip styles */
              [data-radix-tooltip-content] {
                background-color: #2f3e46 !important;
                color: #cad2c5 !important;
                border: 1px solid #52796f !important;
                font-size: 0.875rem !important;
                padding: 0.5rem !important;
                border-radius: 0.25rem !important;
                max-width: 300px !important;
                z-index: 9999 !important;
                pointer-events: none !important;
              }
              
              /* Ensure tooltip arrows are visible */
              [data-radix-tooltip-arrow] {
                fill: #2f3e46 !important;
                stroke: #52796f !important;
                stroke-width: 1px !important;
              }
              `}
            </style>
            
            <div className="dialog-content">
              <form 
                onSubmit={onSubmit} 
                className="flex-1 flex flex-col overflow-hidden relative p-0 pb-16"
              >
                {/* Header with customer name, phone, and title - outside of border */}
                <div className="flex items-center px-2 py-2 mx-10 mt-2">
                  <div className="flex items-center">
                    <div className="text-xl font-semibold">{customerName || "Πελάτης"}</div>
                    {customerPhone && (
                      <div className="text-sm text-gray-300 ml-4">
                        <span className="mr-1">τηλ:</span>
                        {customerPhone}
                      </div>
                    )}
                    <div className="mx-4 h-4 border-l border-gray-400"></div>
                    <div className="text-sm text-gray-300">
                      {isEditing ? "Επεξεργασία Προσφοράς" : "Νέα Προσφορά"}
                    </div>
                  </div>
                </div>

                {/* Border box with fields */}
                <div className="flex flex-col bg-[#354f52] border border-[#52796f] rounded-md mx-10 mb-2">
                  {/* Source, Date, Contact controls inside border */}
                  <div className="flex justify-center px-3 py-3 gap-8">
                    {/* Source Field */}
                    <div className="flex items-center">
                      <div className="text-[#a8c5b5] text-sm mr-1">
                        Πηγή:
                      </div>
                      <div className="min-w-[150px]">
                        <GlobalDropdown
                          options={sourceOptions.map(option => option.label)}
                          value={getSourceLabel(watch("source"))}
                          onSelect={(label) => setValue("source", getSourceValue(label))}
                          placeholder="Επιλέξτε πηγή"
                          className="bg-[#2a3b42] border-[#52796f] text-[#cad2c5] text-sm truncate hover:border-[#84a98c] hover:shadow-[0_0_0_1px_#52796f] transition-all duration-200 h-8"
                        />
                      </div>
                    </div>
                    
                    {/* Date Field */}
                    <div className="flex items-center">
                      <div className="text-[#a8c5b5] text-sm mr-1">
                        Ημ/νία:
                      </div>
                      <div className="min-w-[170px] relative">
                        <button
                          ref={dateButtonRef}
                          type="button"
                          onClick={toggleCalendar}
                          className="bg-[#2a3b42] border border-[#52796f] text-[#cad2c5] h-8 w-full text-sm rounded-md px-3 text-left hover:border-[#84a98c] hover:shadow-[0_0_0_1px_#52796f] focus:shadow-[0_0_0_2px_#52796f] focus:outline-none transition-all duration-200 flex items-center justify-between"
                        >
                          <span className="truncate">{dateFormatUtils.formatDateForDisplay(watch("offer_date"))}</span>
                          <Calendar className="h-4 w-4 text-[#84a98c] flex-shrink-0" />
                        </button>
                        
                        {isCalendarOpen && (
                          <div 
                            className="absolute z-50 mt-1 bg-[#2a3b42] border border-[#52796f] rounded-md shadow-lg p-2 date-picker-dropdown"
                            style={{ 
                              width: '320px',
                              left: 'calc(50% - 160px)'
                            }}
                          >
                            {/* Enhanced calendar with month navigation */}
                            <div className="mb-2">
                              {/* Month and year header with navigation */}
                              <div className="flex items-center justify-between mb-2">
                                <button 
                                  type="button"
                                  className="text-[#84a98c] hover:text-[#cad2c5] px-2 py-1"
                                  onClick={() => {
                                    const newDate = new Date(calendarDate);
                                    newDate.setMonth(newDate.getMonth() - 1);
                                    setCalendarDate(newDate);
                                  }}
                                >
                                  ‹
                                </button>
                                <div className="text-center text-[#cad2c5] font-semibold">
                                  {calendarDate.toLocaleDateString('el-GR', { month: 'long', year: 'numeric' })}
                                </div>
                                <button 
                                  type="button"
                                  className="text-[#84a98c] hover:text-[#cad2c5] px-2 py-1"
                                  onClick={() => {
                                    const newDate = new Date(calendarDate);
                                    newDate.setMonth(newDate.getMonth() + 1);
                                    setCalendarDate(newDate);
                                  }}
                                >
                                  ›
                                </button>
                              </div>
                              
                              {/* Days of week */}
                              <div className="grid grid-cols-7 gap-1">
                                {['Δε', 'Τρ', 'Τε', 'Πε', 'Πα', 'Σα', 'Κυ'].map(day => (
                                  <div key={day} className="text-center text-[#84a98c] text-xs font-medium">
                                    {day}
                                  </div>
                                ))}
                              </div>
                                
                              {/* Calendar grid with previous/next month days */}
                              <div className="grid grid-cols-7 gap-1 mt-1">
                                {(() => {
                                  const today = new Date();
                                  const currentMonth = calendarDate.getMonth();
                                  const currentYear = calendarDate.getFullYear();
                                  
                                  // Create date for first day of month
                                  const firstDay = new Date(currentYear, currentMonth, 1);
                                  // Get day of week (0 = Sunday, 1 = Monday, etc.)
                                  let firstDayOfWeek = firstDay.getDay();
                                  // Adjust for Monday start (0 = Monday, 6 = Sunday)
                                  firstDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
                                  
                                  // Last day of current month
                                  const lastDay = new Date(currentYear, currentMonth + 1, 0);
                                  const daysInMonth = lastDay.getDate();
                                  
                                  // Get days from previous month
                                  const prevMonth = new Date(currentYear, currentMonth, 0);
                                  const prevMonthDays = prevMonth.getDate();
                                  
                                  // Calendar cells array
                                  const calendarCells = [];
                                  
                                  // Add days from previous month
                                  for (let i = 0; i < firstDayOfWeek; i++) {
                                    const day = prevMonthDays - firstDayOfWeek + i + 1;
                                    const date = new Date(currentYear, currentMonth - 1, day);
                                    calendarCells.push({
                                      day,
                                      date,
                                      type: 'prev-month'
                                    });
                                  }
                                  
                                  // Add days of current month
                                  for (let day = 1; day <= daysInMonth; day++) {
                                    const date = new Date(currentYear, currentMonth, day);
                                    const isToday = day === today.getDate() && 
                                                    currentMonth === today.getMonth() && 
                                                    currentYear === today.getFullYear();
                                    calendarCells.push({
                                      day,
                                      date,
                                      type: 'current-month',
                                      isToday
                                    });
                                  }
                                  
                                  // Add days from next month to fill the grid
                                  const totalCellsNeeded = 42; // 6 rows × 7 days
                                  const nextMonthDays = totalCellsNeeded - calendarCells.length;
                                  for (let day = 1; day <= nextMonthDays; day++) {
                                    const date = new Date(currentYear, currentMonth + 1, day);
                                    calendarCells.push({
                                      day,
                                      date,
                                      type: 'next-month'
                                    });
                                  }
                                  
                                  // Return the calendar cells
                                  return calendarCells.map((cell, index) => {
                                    let className = 'text-center py-1 text-xs rounded h-6';
                                    
                                    if (cell.type === 'current-month') {
                                      className += cell.isToday 
                                        ? ' bg-[#52796f] text-white font-bold' 
                                        : ' text-[#cad2c5] bg-[#354f52] hover:bg-[#52796f]';
                                    } else {
                                      // Previous or next month days
                                      className += ' text-[#a8c5b5] bg-[#2a3b42] opacity-50 hover:opacity-80 hover:bg-[#354f52]';
                                    }
                                    
                                    return (
                                      <button
                                        key={`cell-${index}`}
                                        type="button"
                                        onClick={() => {
                                          // Get current date value to preserve time
                                          const currentDate = new Date(watch("offer_date"));
                                          // Create new date with selected day but preserve time
                                          const selectedDate = new Date(cell.date);
                                          selectedDate.setHours(
                                            currentDate.getHours(),
                                            currentDate.getMinutes(),
                                            currentDate.getSeconds(),
                                            currentDate.getMilliseconds()
                                          );
                                          const dateString = selectedDate.toISOString();
                                          setValue("offer_date", dateString);
                                          setValue("created_at", dateString);
                                          setIsCalendarOpen(false);
                                        }}
                                        className={className}
                                      >
                                        {cell.day}
                                      </button>
                                    );
                                  });
                                })()}
                              </div>
                            </div>
                            
                            {/* Today button and close */}
                            <div className="flex justify-between mt-2">
                              <button 
                                type="button"
                                onClick={() => {
                                  const today = new Date();
                                  const dateString = today.toISOString();
                                  setValue("offer_date", dateString);
                                  setValue("created_at", dateString);
                                  setCalendarDate(today); // Reset calendar view to current month
                                  setIsCalendarOpen(false);
                                }}
                                className="text-[#84a98c] hover:text-[#cad2c5] text-sm"
                              >
                                Σήμερα
                              </button>
                              <button 
                                type="button"
                                onClick={() => setIsCalendarOpen(false)}
                                className="text-[#84a98c] hover:text-[#cad2c5] text-sm"
                              >
                                Κλείσιμο
                              </button>
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                    
                    {/* Contact Field */}
                    <div className="flex items-center">
                      <div className="text-[#a8c5b5] text-sm mr-1">
                        Επαφή:
                      </div>
                      <div className="min-w-[170px]">
                        <div className="flex items-center">
                          <div className="flex-1 min-w-0">
                            <GlobalDropdown
                              options={contactOptions}
                              value={selectedContactId ? getContactDisplayNameById(selectedContactId) : ""}
                              onSelect={(value) => {
                                // Find the contact ID by display name
                                const foundContact = contacts.find(
                                  contact => contact.full_name === value
                                );
                                
                                if (foundContact) {
                                  setSelectedContactId(foundContact.id);
                                }
                              }}
                              placeholder="Επιλέξτε επαφή"
                              disabled={contactOptions.length === 0}
                              className="bg-[#2a3b42] border-[#52796f] text-[#cad2c5] text-sm truncate hover:border-[#84a98c] hover:shadow-[0_0_0_1px_#52796f] transition-all duration-200 h-8"
                            />
                          </div>
                          <button
                            type="button"
                            onClick={() => setShowContactDialog(true)}
                            className="ml-1 bg-[#2a3b42] border border-[#52796f] text-[#84a98c] h-8 w-8 rounded-md flex items-center justify-center hover:bg-[#354f52] hover:border-[#84a98c] transition-all duration-200"
                          >
                            <Plus className="h-4 w-4" />
                          </button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Tabs below the header */}
                <AppTabs 
                  defaultValue="basic" 
                  className="app-tabs-container mt-2 px-10"
                  onValueChange={(value) => {
                    // Initialize tooltips by ensuring all tooltip refs are set to mounted
                    setTimeout(() => {
                      document.querySelectorAll('[data-tooltip-mounted]').forEach(el => {
                        try {
                          if ((el as any).tooltipMountedRef) {
                            (el as any).tooltipMountedRef.current = true;
                          }
                        } catch (e) {
                          // Silent error
                        }
                      });
                    }, 200);
                  }}
                >
                  <AppTabsList className="border-t-0">
                    <AppTabsTrigger value="basic">Βασικά Στοιχεία</AppTabsTrigger>
                    <AppTabsTrigger value="details">Λεπτομέρειες</AppTabsTrigger>
                  </AppTabsList>
                  
                  <div className="flex-1 relative" style={{ minHeight: '600px' }}>
                    {/* Tab 1: Basic Information */}
                    <AppTabsContent value="basic" className="absolute inset-0 pt-2 overflow-auto pointer-events-auto">
                      <BasicTab />
                    </AppTabsContent>
                    
                    {/* Tab 2: Details */}
                    <AppTabsContent value="details" className="absolute inset-0 pt-1 overflow-auto pointer-events-auto">
                      <DetailsTab />
                    </AppTabsContent>
                  </div>
                </AppTabs>
                
                <div className="dialog-footer">
                  {submitError && (
                    <div className="text-red-400 mr-4">{submitError}</div>
                  )}
                  {saveSuccess && (
                    <div className="text-green-400 mr-4">Η προσφορά αποθηκεύτηκε επιτυχώς!</div>
                  )}
                  <Button 
                    type="submit"
                    disabled={isSubmitting || saveSuccess || formDisabled}
                    className="bg-[#52796f] hover:bg-[#354f52] text-[#cad2c5] mr-2"
                  >
                    {isSubmitting ? (
                      <span className="flex items-center">
                        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Αποθήκευση...
                      </span>
                    ) : isEditing ? 'Αποθήκευση' : 'Αποθήκευση'}
                  </Button>
                  <Button
                    type="button" 
                    variant="outline"
                    onClick={() => onOpenChange(false)}
                    className="border-[#52796f] text-[#cad2c5] hover:bg-[#354f52] hover:text-[#cad2c5]"
                  >
                    {saveSuccess ? 'Κλείσιμο' : 'Ακύρωση'}
                  </Button>
                </div>
              </form>

              {/* Contact Dialog */}
              <ContactDialog
                open={showContactDialog}
                onOpenChange={(open) => {
                  setShowContactDialog(open);
                  if (!open) {
                    setSelectedContact(null);
                    // Refresh contacts when dialog closes
                    fetchContacts();
                  }
                }}
                contactId={selectedContact?.id}
                customerId={customerId}
                refreshData={async () => {
                  return Promise.resolve();
                }}
              />

              {/* Delete Offer Dialog */}
              <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
                <AlertDialogContent aria-describedby="delete-offer-description">
                  <AlertDialogHeader>
                    <AlertDialogTitle>Delete Offer</AlertDialogTitle>
                    <AlertDialogDescription id="delete-offer-description">
                      Are you sure you want to delete this offer? This action cannot be undone.
                    </AlertDialogDescription>
                  </AlertDialogHeader>
                  <div className="flex justify-end space-x-2 mt-4">
                    <Button
                      type="button"
                      onClick={() => {
                        // Handle delete logic here
                        setShowDeleteDialog(false);
                      }}
                      className="bg-red-600 hover:bg-red-700 text-white"
                    >
                      Delete
                    </Button>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => setShowDeleteDialog(false)}
                      className="border-[#52796f] text-[#cad2c5] hover:bg-[#354f52] hover:text-[#cad2c5]"
                    >
                      Cancel
                    </Button>
                  </div>
                </AlertDialogContent>
              </AlertDialog>
            </div>
            </ResourceLockWrapper>
          </DialogContent>
        </Dialog>
      </ErrorBoundary>
    </OfferDialogContext.Provider>
  );
});

export default OffersDialog;