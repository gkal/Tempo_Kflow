-- Migration for vulnerability scanning tables and procedures
-- Used by the security scanning services for tracking and managing security vulnerabilities

-- Create vulnerability_scans table to store scan results
CREATE TABLE IF NOT EXISTS public.vulnerability_scans (
  id UUID PRIMARY KEY,
  scan_type TEXT NOT NULL, -- 'dependency', 'code', 'api', 'authentication'
  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  vulnerabilities_found INTEGER NOT NULL DEFAULT 0,
  critical_count INTEGER NOT NULL DEFAULT 0,
  high_count INTEGER NOT NULL DEFAULT 0,
  medium_count INTEGER NOT NULL DEFAULT 0,
  low_count INTEGER NOT NULL DEFAULT 0,
  info_count INTEGER NOT NULL DEFAULT 0,
  scan_duration INTEGER NOT NULL DEFAULT 0, -- in milliseconds
  scan_target TEXT NOT NULL,
  scan_status TEXT NOT NULL, -- 'in_progress', 'completed', 'failed'
  error_message TEXT
);

-- Create vulnerability_details table to store individual vulnerability information
CREATE TABLE IF NOT EXISTS public.vulnerability_details (
  id UUID PRIMARY KEY,
  scan_id UUID NOT NULL REFERENCES public.vulnerability_scans(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  severity TEXT NOT NULL, -- 'critical', 'high', 'medium', 'low', 'info'
  vulnerability_type TEXT NOT NULL,
  location TEXT NOT NULL,
  cwe_id TEXT,
  cve_id TEXT,
  references TEXT[],
  remediation TEXT,
  is_fixed BOOLEAN NOT NULL DEFAULT FALSE,
  fixed_at TIMESTAMPTZ,
  fixed_by UUID REFERENCES public.users(id),
  fix_details TEXT
);

-- Create indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_timestamp ON public.vulnerability_scans(timestamp);
CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_type ON public.vulnerability_scans(scan_type);
CREATE INDEX IF NOT EXISTS idx_vulnerability_details_scan_id ON public.vulnerability_details(scan_id);
CREATE INDEX IF NOT EXISTS idx_vulnerability_details_severity ON public.vulnerability_details(severity);
CREATE INDEX IF NOT EXISTS idx_vulnerability_details_is_fixed ON public.vulnerability_details(is_fixed);

-- Create a function to create the vulnerability_scans table if it doesn't exist
CREATE OR REPLACE FUNCTION public.create_vulnerability_scans_table_if_not_exists()
RETURNS VOID AS $$
BEGIN
  IF NOT EXISTS (
    SELECT FROM pg_tables 
    WHERE schemaname = 'public' 
    AND tablename = 'vulnerability_scans'
  ) THEN
    CREATE TABLE public.vulnerability_scans (
      id UUID PRIMARY KEY,
      scan_type TEXT NOT NULL,
      timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      vulnerabilities_found INTEGER NOT NULL DEFAULT 0,
      critical_count INTEGER NOT NULL DEFAULT 0,
      high_count INTEGER NOT NULL DEFAULT 0,
      medium_count INTEGER NOT NULL DEFAULT 0,
      low_count INTEGER NOT NULL DEFAULT 0,
      info_count INTEGER NOT NULL DEFAULT 0,
      scan_duration INTEGER NOT NULL DEFAULT 0,
      scan_target TEXT NOT NULL,
      scan_status TEXT NOT NULL,
      error_message TEXT
    );
    
    -- Create indexes
    CREATE INDEX idx_vulnerability_scans_timestamp ON public.vulnerability_scans(timestamp);
    CREATE INDEX idx_vulnerability_scans_type ON public.vulnerability_scans(scan_type);
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a function to create the vulnerability_details table if it doesn't exist
CREATE OR REPLACE FUNCTION public.create_vulnerability_details_table_if_not_exists()
RETURNS VOID AS $$
BEGIN
  IF NOT EXISTS (
    SELECT FROM pg_tables 
    WHERE schemaname = 'public' 
    AND tablename = 'vulnerability_details'
  ) THEN
    CREATE TABLE public.vulnerability_details (
      id UUID PRIMARY KEY,
      scan_id UUID NOT NULL,
      title TEXT NOT NULL,
      description TEXT,
      severity TEXT NOT NULL,
      vulnerability_type TEXT NOT NULL,
      location TEXT NOT NULL,
      cwe_id TEXT,
      cve_id TEXT,
      references TEXT[],
      remediation TEXT,
      is_fixed BOOLEAN NOT NULL DEFAULT FALSE,
      fixed_at TIMESTAMPTZ,
      fixed_by UUID,
      fix_details TEXT
    );
    
    -- Add foreign key constraints
    ALTER TABLE public.vulnerability_details 
      ADD CONSTRAINT fk_vulnerability_details_scan_id 
      FOREIGN KEY (scan_id) REFERENCES public.vulnerability_scans(id) 
      ON DELETE CASCADE;
      
    ALTER TABLE public.vulnerability_details 
      ADD CONSTRAINT fk_vulnerability_details_fixed_by 
      FOREIGN KEY (fixed_by) REFERENCES public.users(id);
    
    -- Create indexes
    CREATE INDEX idx_vulnerability_details_scan_id ON public.vulnerability_details(scan_id);
    CREATE INDEX idx_vulnerability_details_severity ON public.vulnerability_details(severity);
    CREATE INDEX idx_vulnerability_details_is_fixed ON public.vulnerability_details(is_fixed);
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a function to retrieve the latest scan of each type
CREATE OR REPLACE FUNCTION public.get_latest_vulnerability_scans()
RETURNS TABLE (
  id UUID,
  scan_type TEXT,
  timestamp TIMESTAMPTZ,
  vulnerabilities_found INTEGER,
  critical_count INTEGER,
  high_count INTEGER,
  medium_count INTEGER,
  low_count INTEGER,
  info_count INTEGER,
  scan_duration INTEGER,
  scan_target TEXT,
  scan_status TEXT
) AS $$
BEGIN
  RETURN QUERY
  WITH latest_scans AS (
    SELECT DISTINCT ON (scan_type) *
    FROM public.vulnerability_scans
    WHERE scan_status = 'completed'
    ORDER BY scan_type, timestamp DESC
  )
  SELECT 
    ls.id, ls.scan_type, ls.timestamp, ls.vulnerabilities_found,
    ls.critical_count, ls.high_count, ls.medium_count, ls.low_count, ls.info_count,
    ls.scan_duration, ls.scan_target, ls.scan_status
  FROM latest_scans ls
  ORDER BY 
    CASE 
      WHEN ls.critical_count > 0 THEN 1
      WHEN ls.high_count > 0 THEN 2
      WHEN ls.medium_count > 0 THEN 3
      ELSE 4
    END,
    ls.timestamp DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a function to clean up old scan data
CREATE OR REPLACE FUNCTION public.clean_old_vulnerability_scans(days_to_keep INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
  deletion_date TIMESTAMPTZ;
  deleted_count INTEGER;
BEGIN
  deletion_date := NOW() - (days_to_keep * INTERVAL '1 day');
  
  -- Count scans to be deleted
  SELECT COUNT(*) INTO deleted_count
  FROM public.vulnerability_scans
  WHERE timestamp < deletion_date;
  
  -- Delete old scans (cascade will delete related details)
  DELETE FROM public.vulnerability_scans 
  WHERE timestamp < deletion_date;
  
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add RLS policies

-- Enable RLS on vulnerability_scans table
ALTER TABLE public.vulnerability_scans ENABLE ROW LEVEL SECURITY;

-- Create policy to allow admins full access
CREATE POLICY admin_vulnerability_scans_policy ON public.vulnerability_scans
  USING (
    EXISTS (
      SELECT 1 FROM public.users
      WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Enable RLS on vulnerability_details table
ALTER TABLE public.vulnerability_details ENABLE ROW LEVEL SECURITY;

-- Create policy to allow admins full access
CREATE POLICY admin_vulnerability_details_policy ON public.vulnerability_details
  USING (
    EXISTS (
      SELECT 1 FROM public.users
      WHERE users.id = auth.uid() AND users.role = 'admin'
    )
  );

-- Grant necessary permissions
GRANT EXECUTE ON FUNCTION public.create_vulnerability_scans_table_if_not_exists TO service_role;
GRANT EXECUTE ON FUNCTION public.create_vulnerability_details_table_if_not_exists TO service_role;
GRANT EXECUTE ON FUNCTION public.get_latest_vulnerability_scans TO service_role;
GRANT EXECUTE ON FUNCTION public.clean_old_vulnerability_scans TO service_role;

COMMENT ON TABLE public.vulnerability_scans IS 'Stores results of security vulnerability scans';
COMMENT ON TABLE public.vulnerability_details IS 'Stores details of individual vulnerabilities found during scans';
COMMENT ON FUNCTION public.create_vulnerability_scans_table_if_not_exists() IS 'Creates the vulnerability_scans table if it does not exist';
COMMENT ON FUNCTION public.create_vulnerability_details_table_if_not_exists() IS 'Creates the vulnerability_details table if it does not exist';
COMMENT ON FUNCTION public.get_latest_vulnerability_scans() IS 'Retrieves the latest scan of each type';
COMMENT ON FUNCTION public.clean_old_vulnerability_scans(INTEGER) IS 'Removes vulnerability scan data older than the specified number of days'; 